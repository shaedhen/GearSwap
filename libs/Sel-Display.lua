--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--
--	Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
--
--	Editing this file will cause you to be unable to use Github Desktop to update!
--
--	Any changes you wish to make in this file you should be able to make by overloading. That is Re-Defining the same variables or functions in another file, by copying and
--	pasting them to a file that is loaded after the original file, all of my library files, and then job files are loaded first.
--	The last files to load are the ones unique to you. User-Globals, Charactername-Globals, Charactername_Job_Gear, in that order, so these changes will take precedence.
--
--	You may wish to "hook" into existing functions, to add functionality without losing access to updates or fixes I make, for example, instead of copying and editing
--	status_change(), you can instead use the function user_status_change() in the same manner, which is called by status_change() if it exists, most of the important 
--  gearswap functions work like this in my files, and if it's unique to a specific job, user_job_status_change() would be appropriate instead.
--
--  Variables and tables can be easily redefined just by defining them in one of the later loaded files: autofood = 'Miso Ramen' for example.
--  States can be redefined as well: state.HybridMode:options('Normal','PDT') though most of these are already redefined in the gear files for editing there.
--	Commands can be added easily with: user_self_command(commandArgs, eventArgs) or user_job_self_command(commandArgs, eventArgs)
--
--	If you're not sure where is appropriate to copy and paste variables, tables and functions to make changes or add them:
--		User-Globals.lua - 			This file loads with all characters, all jobs, so it's ideal for settings and rules you want to be the same no matter what.
--		Charactername-Globals.lua -	This file loads with one character, all jobs, so it's ideal for gear settings that are usable on all jobs, but unique to this character.
--		Charactername_Job_Gear.lua-	This file loads only on one character, one job, so it's ideal for things that are specific only to that job and character.
--
--
--	If you still need help, feel free to contact me on discord or ask in my chat for help: https://discord.gg/ug6xtvQ
--  !Please do NOT message me in game about anything third party related, though you're welcome to message me there and ask me to talk on another medium.
--
--  Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__              
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____      
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \     
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/     
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\ 
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/ 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
-- Job State Display -- Originally written by Talym, modified by Selindrile.
----------------------------------------------------------------------------------------------------
-- Creates a customizable visual job state display for states managed by Modes.lua
--
-- Include in get_sets(), user_setup(), etc, or custom include file
--
-- By default, supports the following modal states:
-- OffenseMode, DefenseMode, HybridMode, IdleMode, WeaponskillMode, CastingMode,
-- MainStep, AltStep, TreasureMode, TotalHaste, DelayReduction
--
-- Additional modal states can be supported by defining a label mapping in update_job_states()
-- Boolean states require no modifications
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
-- Initialize display
-- Call after defining job states in get_sets(), user_setup(), etc.
--
-- required     job_bools   List of boolean-type states to manage
-- required     job_modes   List of modal-type states to manage
--
-- EXAMPLE
-- function user_setup()
--      state.MagicBurst = M(false, 'Magic Burst')
--      state.CastingMode:options('Normal', 'Death')
--      state.IdleMode:options('Normal', 'Death')
--      init_job_states({"MagicBurst"},{"CastingMode","IdleMode"})
-- end
----------------------------------------------------------------------------------------------------
function removeduptt(t1)
local hash = {}
local res = {}
for k,v in pairs(t1) do
   if not hash[v] then
       res[#res+1] = v -- you could print here instead of saving to result table if you wanted
       hash[v] = true
   end   
end
	return res

end
function mergett(t1, t2)
    for k, v in pairs(t2) do
        table.insert(t1,v)
    end
    return t1
end
function init_job_states()

	generalStateList = get_general_states()
	
	stateList = get_specific_states_by_job()
	stateListSub = get_specific_states_by_sjob()
	
	generalBoolList = get_general_toggles()
	
	stateBool = get_specific_toggles_by_job()
	stateBoolSub = get_specific_toggles_by_sjob()
	stateListSize = 0
	stateBoolSize = 0
	generalStateList = mergett(generalStateList,stateList)
	generalStateList = mergett(generalStateList,stateListSub)
	generalBoolList = mergett(generalBoolList,stateBool)
	generalBoolList = mergett(generalBoolList,stateBoolSub)
	generalStateList = removeduptt(generalStateList)
	generalBoolList = removeduptt(generalBoolList)
    if stateBoxModes then stateBoxModes:destroy() end
	if stateBoxBool then stateBoxModes:destroy() end


    local settings = windower.get_windower_settings()
	local x,y
	
	x,y = settings["ui_x_res"]-250, settings["ui_y_res"]/3 -- -285, -18
	
	if displayx then x = displayx end
	if displayy then y = displayy end

	local font = displayfont or 'Arial'
	local size = displaysize or 10
	local bold = displaybold or true
	local bg = displaybg or 0
	local strokewidth = displaystroke or 2
	local stroketransparancy = displaytransparancy or 192
	local toggleNb = 0
	local modeNb = 0
	local currentPositionBool, currentPositionMode = 999
	
    stateBoxModes = texts.new()
	    stateBoxModes:pos(575,0)
    stateBoxModes:font(font)--Arial
    stateBoxModes:size(size)
    stateBoxModes:bold(bold)
    stateBoxModes:bg_alpha(255)--128
    stateBoxModes:right_justified(false)
    stateBoxModes:stroke_width(strokewidth)
    stateBoxModes:stroke_transparency(stroketransparancy)
	
	stateBoxBool = texts.new()
    stateBoxBool:pos(1500,0)
    stateBoxBool:font(font)--Arial
    stateBoxBool:size(size)
    stateBoxBool:bold(bold)
    stateBoxBool:bg_alpha(255)--128
    stateBoxBool:right_justified(false)
    stateBoxBool:stroke_width(strokewidth)
    stateBoxBool:stroke_transparency(stroketransparancy)
	
    update_job_states()

end

----------------------------------------------------------------------------------------------------
-- Update display
-- Call from state_change(), job_state_change(), etc.
----------------------------------------------------------------------------------------------------
function update_job_states()

	if not state.DisplayMode.value then
		if stateBoxModes then stateBoxModes:hide() end
		if stateBoxBool then stateBoxBool:hide() end		return		
	end

    -- Define colors for text in the display
    local clr = {
        h='\\cs(255,192,0)', -- Yellow for active booleans and non-default modals
		w='\\cs(255,255,255)', -- White for labels and default modals
        n='\\cs(192,192,192)', -- White for labels and default modals
        s='\\cs(96,96,96)', -- Gray for inactive booleans
		Fire='\\cs(255,80,80)', -- Red For Fire Element
		Ice='\\cs(140,160,255)', -- Light Blue For Ice Element
		Wind='\\cs(110,255,110)', -- Light Green For Wind Element
		Earth='\\cs(220,214,110)', -- Brown/Yellow For Earth Element
		Lightning='\\cs(190,90,190)', -- Purple For Lightning Element
		Water='\\cs(110,110,255)', -- Blue For Water Element
		Light='\\cs(255,255,155)', -- Light Yellow For Light Element
		Dark='\\cs(90,90,90)', -- Dark Grey For Dark Element
    }
    if state.DisplayColors then
		clr = state.DisplayColors
	end

    local info = {}
    local orig = {}
    local spc = '    '
    -- Define labels for each state
    local labels = {
		Weapons = "Weapons",
		UnlockWeapons = "Unlock Weapons",
        OffenseMode = "Offense",
		RangedMode = "Ranged",
        DefenseMode = "Defense",
        HybridMode = "Hybrid",
        IdleMode = "Idle",
		Passive = "Passive",
		PetMode = "Pet Mode",
		AutoManawell = "A-Manawell",
        WeaponskillMode = "Weaponskill",
        CastingMode = "Casting",
        MainStep = "Main Step",
        AltStep = "Alt Step",
        TreasureMode = "Treasure",
		AutoBuffMode = "A-Buff",
        TotalHaste = "Haste",
        DelayReduction = "Delay",
		LearningMode = "Learning",
		ElementalWheel = "Elem Wheel",
		MagicBurstMode = "MB",
		SkillChainMode = "SCMode",
		RecoverMode = "Recup MP",
		ElementalMode = "Element",
		ExtraSongsMode = "Songs",
		AutoStunMode = "A-Stun",
		LuzafRing = "Luzaf's Ring",
		AutoDefenseMode = "A-Defense",
		AutoTrustMode = "A-Trust",
		JugMode = "Pet",
		RewardMode = "Reward",
		AutoNukeMode = "A-Nuke: "..autonuke.."",
		AutoSongMode = "A-Song",
		AutoJumpMode = "A-Jump",
		AutoWSMode = "A-WS: "..autows..": "..autowstp.."",
		AutoShadowMode = "A-Utsu",
		AutoFoodMode = "A-Food: "..autofood.."",
		RngHelper = "RngHelper",
		RngHelperQuickDraw = "RngHelperQuickDraw",
		Capacity = "CP",
		AutoTankMode = "A-Tank",
		CompensatorMode = "Compensator",
		WeaponsSongMode = "WeaponsSongs",
		DrainSwapWeaponMode = "Drain Swap",
		AutoRuneMode = "Auto Rune: "..state.RuneElement.value.."",
		AutoEffusionMode = "Auto Effusion",
		AutoSambaMode = "Auto Samba: "..state.AutoSambaMode.value.."",
		PhysicalDefenseMode = "P-Defense",
		MagicalDefenseMode = "M-Defense",
		ResistDefenseMode = "R-Defense",
		RuneElement = "Rune Elem",
		AutoReadyMode = "A-Ready",
		AutoPuppetMode = "A-Puppet",
		AutoRepairMode = "A-Repair",
		AutoDeployMode = "A-Deploy",
		AutoPetMode = "A-Pet",
		PetEnmityGear = "PetEnmG",
		PactSpamMode = "Pact Spam",
		PetWSGear = "PetWSGear",
		DanceStance = "DanceStance",
		Stance = "Stance",
		AutoBondMode = "A-Bond",
		ShowDistance = "Show Distance",
		AutoEntrust = "A-Entrust",
		CombatEntrustOnly = "Combat Entrust Only",
		AutoGeoAbilities = "Auto Geo Abilities",
		AutoBuffBP = "A-Buff BP",
		AutoFavor = "A-Favor",
		AutoConvert = "A-Convert",
		AutoCaress = "A-Caress",
		Gambanteinn = "Gambanteinn",
		BlockLowDevotion = "BlockLowDevotion"
    }

    stateBoxModes:clear()
	stateBoxModes:append(' ')
	stateBoxBool:clear()
	stateBoxBool:append(' ')
	--Reinitialize these two
	stateListSize = 0
	stateBoolSize = 0
	
    -- Construct and append info for boolean states
    if false then
	for i,n in pairs(generalBoolList) do

        -- Define color for modal state
        if state[n].index then
			if n == 'AutoWSMode' and state.AutoWSMode.value then
				if state.RngHelper.value then
					stateBoxBool:append(string.format("%sAuto WS: "..rangedautows..": "..rangedautowstp.."%s", clr.h, clr.n))
				else
					stateBoxBool:append(string.format("%sAuto WS: "..autows..": "..autowstp.."%s", clr.h, clr.n))
				end
				
			elseif n == 'AutoDefenseMode' then
				if state.AutoDefenseMode.value then
					if state.TankAutoDefense.value then
						stateBoxBool:append(string.format("%sAuto Defense: Tank%s", clr.h, clr.n))
					else
						stateBoxBool:append(string.format("%sAuto Defense%s", clr.h, clr.n))
					end
					
				end
			else
		--	add_to_chat(217, 'looking for display  '..n..'')
				stateBoxBool:append(clr.h..labels[n]..clr.n)
				
			end
		else
	--	add_to_chat(217, 'looking for display  '..n..'')
	stateBoxBool:append(clr.s..labels[n]..clr.n)
		end
			stateBoxBool:append(spc)
        -- Append basic formatted boolean state
	end
    end
		--stateBoxBool:append(clr.w)
    -- Construct and append info for modal states
	if generalStateList then
    		
	for i,n in ipairs(generalStateList) do		
		if state[n] then

	stateBoolSize = stateBoolSize+1
	if i == currentPositionMode then
		stateBoxModes:append(string.format("%s"..currentSelection.."%s",clr.h,clr.n))
	end
	modeNb = i
        -- Format total haste and delay reduction as percentages
--add_to_chat(217, 'looking for display  '..n..'')
        if n == 'TotalHaste' or n == 'DelayReduction' then
            info[n] = state[n]..'%'
            orig[n] = '0%'
        else
		--add_to_chat(217, 'looking for displayc  '..state[n].current..'')

            info[n] = state[n].current
            orig[n] = state[n][1]
        end
        if info[n] ~= orig[n] then
            info[n] = clr.h..info[n]..clr.n
        end

        -- Append basic formatted modal state


        -- Add additional information for active hybrid defense mode
		if n == 'AutoBuffMode' then
--			if state.AutoBuffMode.value ~= 'Off' then
				if player.main_job == 'GEO' then
					stateBoxModes:append(string.format("%sBuff: Indi-"..autoindi.." Geo-"..autogeo.."%s  ", clr.h, clr.n))
					stateBoxModes:append(spc)
					if autoentrust ~= 'None' then
						stateBoxModes:append(string.format("%sEntrust: "..autoentrust.."  Entrustee: "..autoentrustee.."%s  ", clr.h, clr.n))
						stateBoxModes:append(spc)
					end
				end
				stateBoxModes:append(string.format("%sBuff: %s%s", clr.w, clr.h, state.AutoBuffMode.value))
				--stateBoxModes:append(spc)
--			end
		elseif n == 'RangedMode' then
			stateBoxModes:append(string.format("%s%s: ${%s} ", clr.w, labels[n], n))
				if statusammo then
					stateBoxModes:append('Ammo: '..statusammo..'    ')
				end
		elseif n == 'OffenseMode' then
			if state.DefenseMode.value ~= 'None' then
				stateBoxModes:append(string.format("%sDefense Active: ", clr.w))
				if state.DefenseMode.value == 'Physical' then
					stateBoxModes:append(string.format("%s%s: %s%s", clr.h, state.DefenseMode.current, state.PhysicalDefenseMode.current, clr.w))
				elseif state.DefenseMode.value == 'Magical' then
					stateBoxModes:append(string.format("%s%s: %s%s", clr.h, state.DefenseMode.current, state.MagicalDefenseMode.current, clr.w))
				elseif state.DefenseMode.value == 'Resist' then
					stateBoxModes:append(string.format("%s%s: %s%s", clr.h, state.DefenseMode.current, state.ResistDefenseMode.current, clr.w))
				end
				if state.ExtraDefenseMode and state.ExtraDefenseMode.value ~= 'None' then
					stateBoxModes:append(string.format("%s / %s%s%s", clr.n, clr.h, state.ExtraDefenseMode.current, clr.n))
				end
				stateBoxModes:append(spc)
			else
				stateBoxModes:append(string.format("%s%s: ${%s}", clr.w, labels[n], n))
				if state.HybridMode then
					if state.HybridMode.value == 'Normal' then
						stateBoxModes:append(string.format("%s / %s%s%s", clr.n, clr.w, state.HybridMode.current, clr.n))
					else
						stateBoxModes:append(string.format("%s / %s%s%s", clr.n, clr.h, state.HybridMode.current, clr.n))
					end
				end
				--if state.ExtraMeleeMode then
				--	if state.ExtraMeleeMode.value == 'None' then
				--		stateBoxModes:append(string.format("%s / %s%s%s", clr.n, clr.w, state.ExtraMeleeMode.current, clr.n))
				--	else
				--		stateBoxModes:append(string.format("%s / %s%s%s", clr.n, clr.h, state.ExtraMeleeMode.current, clr.n))
				--	end
				--end
			--	stateBoxModes:append(spc)
			end
		elseif n == 'HasteLevel' then
			if (player.main_job == 'NIN' or player.main_job == 'DNC'or player.main_job == 'THF' or player.sub_job == 'NIN' or player.sub_job == 'DNC') then
				stateBoxModes:append(string.format("%sHaste: %s%s ", clr.w, clr.h, state.HasteLevel.value))
			end
		elseif n == 'AutoSambaMode' then
		--	if state.AutoSambaMode.value ~= 'Off' then
				stateBoxModes:append(string.format("%sSamba: %s%s ", clr.w, clr.h, state.AutoSambaMode.value))
		--	end
		elseif n == 'IdleMode' then
		--	if state.IdleMode.value ~= 'Normal' and state.DefenseMode.value == 'None' then
				stateBoxModes:append(string.format("%s%s: ${%s} ", clr.w, labels[n], n))
		--	end
			if state.Kiting.value then
				stateBoxModes:append(string.format("%sKiting: %sOn ", clr.w, clr.h))
			end
		elseif n == 'Passive' then
		--	if state.Passive.value ~= 'None' and state.DefenseMode.value == 'None' then
				stateBoxModes:append(string.format("%s%s: ${%s} ", clr.w, labels[n], n))
		--	end
		elseif n == 'TreasureMode' then
		--	if (state.TreasureMode.value ~= 'None' or player.main_job == 'THF') and state.DefenseMode.value == 'None' then
				stateBoxModes:append(string.format("%sTreasure: %s%s ", clr.w, clr.h, state.TreasureMode.value))
		--	end
		elseif n == 'CastingMode' then
			stateBoxModes:append(string.format("%s%s: ${%s} ", clr.w, labels[n], n))
		elseif n == 'MagicBurstMode' then
		--	if state.MagicBurstMode.value ~= 'Off' then
			stateBoxModes:append(string.format("%sMagic Burst: %s%s ", clr.w, clr.h, state.MagicBurstMode.value))
		--	end
			if state.DeathMode and state.DeathMode.value ~= 'Off' then
				stateBoxModes:append(string.format("%sDeath Mode: %s%s ", clr.w, clr.h, state.DeathMode.value))
			end
		elseif n == 'WeaponskillMode' then
		--	if state.WeaponskillMode.value ~= 'Match' then
				stateBoxModes:append(string.format("%sWeaponskill: %s%s ", clr.w, clr.h, state.WeaponskillMode.value))
		--	end
		elseif n == 'SkillchainMode' then
		--	if state.SkillchainMode.value ~= 'Off' and state.DefenseMode.value == 'None' then
				stateBoxModes:append(string.format("%sSkillchain Mode: %s%s ", clr.w, clr.h, state.SkillchainMode.value))
		--	end
		elseif n == 'ElementalMode' then
				stateBoxModes:append(string.format("%sElement: %s%s ", clr.w, clr[state.ElementalMode.value], state.ElementalMode.value))
		elseif n == 'RuneElement' then
		--		if not state.AutoRuneMode.value and (player.main_job == 'RUN' or player.sub_job == 'RUN') then
					stateBoxModes:append(string.format("%sRune: %s%s ", clr.w, clr[data.elements.runes_lookup[state.RuneElement.value]], state.RuneElement.value))
		--		end
		elseif n == 'LearningMode' then
		--	if state.LearningMode.value and state.DefenseMode.value == 'None' then
				stateBoxModes:append(string.format("%sLearning: %sOn ", clr.w, clr.h))
		--	end
		elseif n == 'CompensatorMode' then
		--	if state.CompensatorMode.value ~= 'Never' then
				stateBoxModes:append(string.format("%sCompensator: %s%s ", clr.w, clr.h, state.CompensatorMode.value))
		--	end
		elseif n == 'DrainSwapWeaponMode' then
		--	if state.DrainSwapWeaponMode.value ~= 'Never' then
				stateBoxModes:append(string.format("%sDrain Swap: %s%s ", clr.w, clr.h, state.DrainSwapWeaponMode.value))
		--	end
		elseif n == 'ExtraSongsMode' then
		--	if state.ExtraSongsMode.value ~= "None" then
				stateBoxModes:append(string.format("%sSongs: %s%s ", clr.w, clr.h, state.ExtraSongsMode.value))
		--		end
		elseif n == 'DanceStance' then
		--	if state.DanceStance.value ~= "None" then
				stateBoxModes:append(string.format("%sDance: %s%s ", clr.w, clr.h, state.DanceStance.value))
		--	end
		elseif n == 'Stance' then
		--	if state.Stance.value ~= "None" then
				stateBoxModes:append(string.format("%sStance: %s%s ", clr.w, clr.h, state.Stance.value))
		--	end
	--	else
	--		stateBoxModes:append(string.format("%s%s: ${%s}    ", clr.w, labels[n], n))
		end
		stateBoxModes:append(spc)	

    end
	
	if state.ExtraDefenseMode and state.ExtraDefenseMode.value ~= 'None' and state.DefenseMode.value == 'None' then
		stateBoxModes:append(string.format("%sExtra Defense: %s%s ", clr.w, clr.h, state.ExtraDefenseMode.value))
	end
    -- Update and display current info
    stateBoxModes:update(info)
    stateBoxModes:show()
	stateBoxBool:update(info)
    stateBoxBool:show()
end
end
end
----------------------------------------------------------------------------------------------------
-- Clean up display objects
-- Call from file_unload(), user_unload(), etc.
----------------------------------------------------------------------------------------------------
function clear_job_states()
    if stateBoxModes then stateBoxModes:destroy() end
	if stateBoxBool then stateBoxBool:destroy() end

end


windower.raw_register_event('outgoing chunk', function(id, data)
    if id == 0x00D and stateBoxModes then
        stateBoxModes:hide()
    end
	if id == 0x00D and stateBoxBool then
        stateBoxBool:hide()
    end
end)

windower.raw_register_event('incoming chunk', function(id, data)
    if id == 0x00A and stateBoxModes and state.DisplayMode.value then
        stateBoxModes:show()
    end
	if id == 0x00A and stateBoxBool and state.DisplayMode.value then
        stateBoxBool:show()
    end
end)
